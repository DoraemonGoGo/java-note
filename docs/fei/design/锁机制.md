# 锁机制

锁，实际上是一个标记，只要保证多个程序都拥有对这个标记的可见性和操作原子性，这个标记就能充当锁的角色

锁，用于解决多个程序同时对可变共享变量进行修改时，将这样的并发修改变成线性修改

* 单进程系统

  java中`synchronized`是在对象头设置标记，`Lock`类用一个`volatile`变量进行标记，`linux`内核中利用互斥量或信号量进行标记

  多线程由于可以共享堆内存，因此可以简单地采用内存数据作为标记

* 多进程系统

  进程之间可能都不在同一台物理机上，只需将标记存储在一个所有进程都具有其可见性和操作原子性的地方，如`redis`，`mysql`等公共内存资源

## 分布式锁(多进程)

* 基于数据库
  * 基于表主键
  * 基于表字段版本号
  * 基于数据库排他锁

* 基于`redis`
  * 基于`setnx`，基于`expire`
  * 基于`setnx`，`get`，`getset`

* 基于`zookeeper`
  * 基于普通节点
  * 基于有序临时节点

## 锁的分类

公平锁与非公平锁：从其它等待中的线程是否按顺序获取锁的角度划分

* 公平锁：`new ReentrantLock(true)`
* 非公平锁：`new ReentrantLock()`，`synchronized`

互斥锁：从能否有多个线程持有同一把锁的角度划分

重入锁(递归锁)与不可重入锁(自旋锁)：从一个线程能否递归获取自己已经持有的锁的角度划分

锁消除与锁粗化：从编译器优化的角度划分

* 消除：对不会引起安全问题的同步代码取消同步
* 粗化：对多次执行同步的代码合并到一次同步中

类锁与对象锁：在不同的位置使用`synchronized`

* 类锁：使用字节码(`.class`)文件作为锁
* 对象锁：使用对象实例作为锁

悲观锁(互斥锁)与乐观锁(非互斥锁)：从锁的设计理念来划分

* 悲观锁：认为写多读少，遇到并发写的可能性高，每次读写数据都会上锁
* 乐观锁：认为写少读多，遇到并发写的可能性低，每次读都不会上锁，写都会判断一下这个数据有没有被其它程序进行过更新操作(读取当前版本号，上锁判断版本号是否跟预期一样，一样则更新，不一样则重复<读-比较-写>的`CAS`操作)

偏向锁、轻量级锁、重量级锁：从锁的不同效率来划分

`MySql`中的锁

* 共享锁(读锁，S锁)

  事务T对数据A加上共享锁后，其它事务只能对数据A再加共享锁，不能加排他锁

  获得共享锁的事务只能读取数据，不能修改数据

* 排他锁(独占锁，写锁，X锁)

  事务T对数据A加上排他锁后，其它事务不能再对数据A加任何类型的锁

  获得排他锁的事务既能读取数据，又能修改数据

死锁与活锁：因为并发问题而产生的锁

* 死锁，两个程序流都处于阻塞状态
* 活锁，两个程序流都不会发生阻塞，而是不停地进行尝试，程序没有实际进展

java中的锁

* 悲观锁
  * 重量级锁
    * `synchronized`(非公平锁)

      `contention list`：竞争队列，所有请求锁的线程首先会被放到这个竞争队列中

      `entry list`：`contention list`中那些有资格成为获取锁的线程会被移动到`entry list`中

      `wait set`：哪些调用`wait`方法被阻塞的线程会被放置到这里

      `ondeck`：任意时刻，最多只有一个线程正在竞争锁资源，该线程被称为`ondeck`

      `owner`：当前已经获取到锁资源的线程被称为`owner`

      `!owner`：当前释放锁资源的线程

* 乐观锁
  * 自旋锁

    如果持有锁的线程能在短时间内释放锁资源，那么那些等待锁的线程就不需要做内核态和用户态之间的切换而进入阻塞挂起的状态，它们只需要等一等(自旋)，等待持有锁的线程释放锁后即可立即获取锁，这样就避免用户态与内核态之间的切换带来的性能消耗

    自旋的CPU消耗小于线程阻塞挂起再唤醒的消耗，则启用自旋锁

    自旋的CPU消耗大于线程阻塞挂起再唤醒的消耗，则关闭自旋锁

  * 轻量级锁

    加锁过程

      1. 如果同步对象锁状态为无锁状态，则将在当前线程的栈中建立一个锁记录(`lock record`)的空间，用于存储锁对象目前的`mark word`的拷贝(`displaced mark word`)
      2. 拷贝对象头中的`mark work`复制到锁记录中

  * 偏向锁

    只存在一个线程访问，不存在多线程争用时，线程是不需要触发同步的，这种情况就会给线程加一个偏向锁

    如果在运行过程中，遇到其它线程抢占锁，持有偏向锁的线程会被挂起，jvm会消除它持有的偏向锁，将锁恢复为标准的轻量级锁

    获取

      1. 访问`markword`确认是否为可偏向状态，可偏向状态则进入`step 2`
      2. 判断`markword`中的线程id是否为指向当前线程，是则进入`step 5`，否则进入`step 3`
      3. 当前线程通过`CAS`竞争锁，竞争成功则将`markword`的线程id设置为当前线程id，然后进入`step 5`，否则进入`step 4`
      4. `CAS`获取锁失败说明有线程竞争，当到达全局安全点时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码
      5. 执行同步代码

    释放

      1. 线程不会主动释放偏向锁，只有遇到其它线程尝试竞争偏向锁时才会释放偏向锁
      2. 持有偏向锁的线程需要等到全局安全点(这段时间没有字节码正在执行)，先阻塞(`stop the word`，时间很短)，持有偏向锁的线程，判断锁对象是否处于锁定状态，再撤销偏向锁后恢复到未锁定或轻量级锁的状态

## CAS(compare and swap)

CPU的锁

1. 单处理器能自动保证同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作不能自动保证原子性
2. 使用总线锁保证原子性：一个处理器在总线上输出`LOCK`信号，其它处理器的请求将被阻塞，那么该处理器就可以独占使用共享内存
3. 使用缓存锁定保证原子性

CAS的缺点

1. ABA问题 -> 使用版本号解决
2. 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销 -> 用处理器的`pause`指令解决
3. 只能保证一个共享变量的原子操作 -> 把多个共享变量合并成一个共享变量
