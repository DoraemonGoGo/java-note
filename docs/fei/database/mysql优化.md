# MySql优化

## MySql索引

`MySql`索引种类

* 非聚合索引

  检索单个字段速度快

* 聚合索引

  检索多个字段速度快，因为数据存放在存储设备上的物理位置是按顺序的

聚合索引的最左前缀原则

```sql
-- 创建了(name-data)的聚合索引
-- 能使用上聚合索引的sql
select * from test where name = 'fjh' and data = 'text';
select * from test where name = 'fjh';
select * from test where data = 'text' and name = 'fjh';
-- 不能使用上聚合索引的sql
select * from test where data = 'text';
```

在执行查询sql时，`MySql`只会从多个可用索引中挑选一个最优的索引来使用(有时候甚至不用索引)

索引提高了检索的效率，但是会降低修改表数据的效率

列中存在`null`值，就不会使用索引

使用短小的索引，能提高查询效率和节省磁盘空间

`MySql`只对`<`，`<=`，`=`，`>=`，`>`，`between`，`in`以及`like`(不以通配符`%`或`_`开头的情况)等语句使用索引

## MySql的锁机制

`InnoDB`引擎支持事务，支持行级锁和表级锁

`MyISAM`引擎不支持事务，只支持表级锁

* 表级锁

  开销小，加锁快，锁定粒度大，发生锁冲突的概率最高，并发能力最低，不会出现死锁

* 页级锁

  开销、加锁、锁定粒度、发生锁冲突的概率、并发能力在表级锁和行级锁之间，会出现死锁

* 行级锁

  开销大，加锁慢，锁定粒度小，发生锁冲突的概率最低，并发能力最高，会出现死锁

### 死锁

`InnoDB`有专门检测死锁的机制，会自动在产生死锁的事务中做选择，影响记录数多的事务会执行，影响记录数少的事务会回滚

> 可以通过锁定超时参数`InnoDB_lock_wait_timeout`，来避免积压大量因无法获取锁而挂起的事务来压垮数据库

### 储存引擎中的锁

#### `MyISAM`引擎

* 表共享读锁(`Table Read Lock`)

  不会阻塞其它用户对同一个表的读操作，但会阻塞其它用户对同一个表的写操作

* 表独占写锁(`Table Write Lock`)

  阻塞其它用户对同一个表的读和写操作

执行`select`前，会自动给涉及的表加表共享读锁

执行`update`，`delete`，`insert`前，会自动给涉及的表加表独占写锁

用户一般不需要直接用`LOCK TABLE`语句给表显式加表级锁

表级锁优化的关键在于：提高并发度

* 查看表级锁争用情况

  ```sql
  show status like 'Table%';-- 查看表状态
  -- Table_locks_immediate 产生表级锁定的次数
  -- Table_locks_waited 出现表级锁定争用而且发生等待的次数
  ```

* 尽量缩短锁定的时间

  减少检索的执行时间

* `MyISAM`的并发插入

  `concurrent_insert=2`，无论`MyISAM`表中有没有空隙，都允许在表尾并发插入记录

  `concurrent_insert=1`，如果`MyISAM`表中没有空隙，`MyISAM`允许在表尾并发插入记录(默认值)

  `concurrent_insert=0`，不允许并发插入

  通过定期在系统空闲时段执行`OPTIMIZE TABLE`语句来整理空间碎片，回收因删除记录而产生的空隙

* 合理利用读写优先级

  `MySql`的表级锁在默认情况下，写优先级要大于读优先级

  `SET LOW_PRIORITY_UPDATES=1`，使读优先级大于写优先级，也可以指定`insert`，`update`，`delete`语句的`LOW_PRIORITY`属性，降低语句的优先级

#### `InnoDB`引擎

* 共享锁(S)

  允许其它事务去读数据，阻止其它事务获得相同数据集的排他锁

* 排他锁(X)

  允许获得排他锁的事务读写数据，阻止其它事务获得相同数据集的共享锁和排他锁

* 意向共享锁(IS)

  事务打算给数据行加行级共享锁，事务在给一个数据行加行级共享锁前必须先取得该表的IS锁

* 意向排他锁(IX)

  事务打算给数据行加行级排他锁，事务在给一个数据行加行级排他锁前必须先取得该表的IX锁

共享锁和排他锁都是行级锁，意向锁都是表级锁，应用中我们只会使用共享锁和排他锁，意向锁是`MySql`内部使用的，不需要用户干扰

意向锁是为了使得行级锁和表级锁能够共存，从而实现多粒度的锁机制

`InnoDB`表存在两种表级锁

1. `LOCK TABLE`语句显式指定的表级锁
2. 由`InnoDB`自动添加的意向锁

|锁类型|表共享锁S|表排他锁X|意向共享锁IS|意向排他锁IX|
|:-:|:-:|:-:|:-:|:-:|
|表共享锁S|兼容|冲突|兼容|冲突|
|表排他锁X|冲突|冲突|冲突|冲突|
|意向共享锁IS|兼容|冲突|兼容|兼容|
|意向排他锁IX|冲突|冲突|兼容|兼容|

对于`update`，`delete`，`insert`，`InnoDB`会自动给涉及的数据集加排他锁X

对于普通的`select`，`InnoDB`不会加任何锁，事务可以通过以下语句显式加共享锁或排他锁

```sql
-- 加共享锁S
select * from test where name = 'fjh' lock in share mode
-- 加排他锁X
select * from test where name = 'fjh' for update
```

`InnoDB`引擎的行级锁是通过给索引上的索引项加锁来实现的，所以只有使用索引检索数据时，`InnoDB`才会使用行级锁，否则`InnoDB`将使用表级锁

#### 间隙锁(`Next-Key`锁)

当我们用范围条件而不是相等条件检索数据，并请求共享锁或排他锁时，`InnoDB`会给符合条件的数据行的索引项加锁

对于字段值在条件范围内但又不存在的记录行，叫做间隙，`InnoDB`也会对这个间隙加锁，这种锁被称为间隙锁

间隙锁的作用：防止幻读

## `explain`执行计划

* `id`：选择标识符

  sql的执行顺序，id越大越先执行，id相同的，从上往下执行

* `select_type`：表示查询的类型
* `table`：涉及本环节的表
* `partitions`：匹配的分区
* `type`：对表的访问方式，表示`MySql`在表中找到行的方式
  * `all`

    遍历全表(`Full Table Scan`)

  * `index`

    遍历索引树(`Full Index Scan`)

    `index`要先读索引再获取表中的数据，因此`index`查出来的结果集是按照索引的顺序排列的

    `index`的效率比没有排序的`all`低，比需要排序的`all`高

  * `range`

    只检索给定范围的行，然后使用索引来选择行

  * `ref`

    查找条件列使用了索引而且索引不为主键或`unique`，虽然使用了索引，但该索引不是唯一性的索引，所以使用索引快速地找到了第一条匹配的记录行，也不会停止检索

    索引是有序的，第一个匹配的索引项找到后，相同的索引项也会很快被找到，所以不需要扫描全表

  * `ref_eq`

    `ref_eq`与`ref`唯一不同的地方是`ref_eq`使用了主键或唯一性的索引，使用索引找到匹配的记录行后就停止检索，效率比`ref`高

  * `const`

    使用主键进行检索，`MySql`优化器会把这次查询优化成一个常量，至于如何优化以及何时优化，这个取决于优化器

* `possible_keys`：查询时，可能用到的索引
* `key`：查询时，实际用到的索引
* `key_len`：索引的长度(定义的长度，而非实际使用到的长度)
* `ref`：列与索引的比较
* `rows`：扫描行数的估算值
* `filtered`：按`where`过滤的行的百分比
* `Extra`：`MySql`解决查询的详细信息
  * `Using where`

    不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部请求列都是同一个索引的部分的时候，表示`MySql`将在存储引擎检索行后再进行过滤

  * `Using temporary`

    表示`MySql`需要使用临时表来存储结果集，常见于排序和分组查询

  * `Using filesort`

    查询中包含`order by`操作且无法利用索引完成的排序操作称为文件排序

  * `Using index`

    查询的数据，刚好是索引列时，因此无需在表中获取数据
