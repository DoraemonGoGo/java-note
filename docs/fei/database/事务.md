# 事务

## 事务(transaction)

* 事务的特性：ACID
* 事务的边界：开始边界(开始事务),结束边界(提交事务或回滚事务)
* 事务的隔离：4个级别，多个事务并发执行时才需要考虑并发事务

## 事务的四大特性(ACID)

### 原子性(Atomicity)

事务中所有操作是一个不可再分割的原子单位，它们要么全部执行成功，要么全部执行失败

### 一致性(Consistency)

如转账业务，无论事务执行与否，参与转账的两个账号余额之和应该是不变的

### 隔离性(Isolation)

在并发操作中，不同事务之间应该隔离开来，让每个并发中的事务不会互相干扰

### 持久性(Durability)

一旦事务提交成功，事务中所有的数据操作都必须持久化到数据库中

## JDBC中操作事务

同一个事务中所有的操作，都使用同一个`Connection`对象

```java
// JDBC处理事务的常规模板
try {
    Connection.setAutoCommit(boolean);// 设置是否自动提交事务，默认为true
    Connection.commit();// 提交事务
} catch (Exception e) {
    Connection.rollback();// 回滚事务
}
```

## 并发事务常见问题

### 第一类丢失更新

事务A先获取记录C，事务B获取记录C并提交更新，事务A提交更新记录C时发生异常回滚，事务B的更新就会丢失

### 脏读(dirty read)

事务A能获取事务B未提交的更新操作

### 不可重复读(unrepeatable read)

事务A先获取记录C，事务B获取记录C并提交更新，事务A再次获取记录C，事务A前后两次读取的记录C不一致

### 第二类丢失更新

事务A先获取记录C，事务B获取记录C并提交更新，事务A在第一次获取的记录C上进行提交更新，事务B的更新就会被覆盖而丢失

### 幻读(phantom read)

事务A先获取结果集C，事务B向结果集C插入数据并提交，事务A再次获取结果集C，事务A前后两次读取的结果集C的记录条数不一致

> 不可重复读和幻读的区别
>
> * 不可重复读是读取到了另一个事务的数据更新
> * 幻读是读取到了另一事务的数据插入

## 隔离级别

隔离级别越高，数据库的并发处理能力就越差

### SERIALIZABLE(串行读)

不会出现任何并发问题，因为它对同一数据的访问是串行的，非并发访问的；并发处理能力最差

### REPEATABLE_READ(重复读)

解决第一类丢失更新、脏读、不可重复读、第二类丢失更新等问题，但会出现幻读；并发处理能力比`SERIALIZABLE`好

### READ COMMITTED(提交读)

解决第一类丢失更新、脏读等问题，但会出现不可重复读、第二类丢失更新、幻读等问题；并发处理能力比`REPEATABLE_READ`好

### READ UNCOMMITTED(未提交读)

解决第一类丢失更新问题，但会出现脏读、不可重复读、第二类丢失更新、幻读等问题；并发处理能力最好
