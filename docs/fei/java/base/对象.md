# 对象

## 基本类型

* 整数类型(`byte 8 bit`，`short 16 bit`，`int 32 bit`，`long 64 bit`)
* 浮点类型(`float 32 bit`，`double 64 bit`)
* 字符类型(`char 16 bit`)
* 布尔类型(`boolean 1 bit`)

## 引用类型(复杂类型)

* 类(`class`)
* 接口(`interface`)
* 数组(`[]`)

## 类(`class`)

字段(`field`)：字段可以是任何类型的对象

方法(`method`)：包括名称，参数，返回值，方法体，(方法名和参数列表被称为方法签名，它是方法的唯一标识)

## 作用域(`scope`)

作用域决定了变量的可见性和生命周期

## 静态(`static`)

`static`域和`static`方法都跟类的对象实例没任何关联

`static`不能应用于局部变量

构造方法实际上也是静态方法

## 对象初始化

### 触发

1. 创建对象实例
2. 访问`static`域或方法

### 过程(从父类到子类执行)

1. 类资源(只加载一次)
    1. 编译器找到`.class`并加载
    2. `static`域 -> 默认值零值 -> 显示赋值
    3. 静态代码块

2. 实例资源
    1. 堆上分配内存
    2. 域 -> 默认值零值 -> 显示赋值
    3. 代码块
    4. 构造器

### this

调用对象方法时，即发送消息给对象，编译器会自动把所操作对象的引用作为第一个参数`this`传递给所调用的方法

使用`this.xxx`来避免变量名相同导致的冲突问题

### 构造器

使用`this(...)`来调用构造函数

`this(...)`只能在构造函数的第一句中使用，每个构造函数只能调用一次

### 变量的默认值

* 方法中的局部变量

  编译器不会为它赋上默认值

* 类的成员变量和`static`变量

  基本类型：编译器会赋上默认值

  引用类型：编译器会赋上`null`值

### 变量的初始化顺序

在定义类成员变量时赋值，初始化的顺序要正确，编译器会对向前引用发出警告

在类的内部，变量定义的先后顺序决定了初始化的顺序

> 即使变量定义散布在方法定义之间，它们仍会保证在任何方法被调用前完成初始化

## 清理的顺序

销毁的顺序应该和初始化的顺序相反

* 对于字段，则意味着与声明的顺序相反
* 对于继承，应该先清理子类，再清理父类，因为子类可能会依赖父类

## 清理

### `finalize()`

一旦垃圾回收器准备好回收对象占用的内存，先调用`finalize()`方法，并在下一次垃圾回收器准备好回收对象占用的内存时，才会真正回收对象占用的内存

垃圾回收器能回收java程序创建的对象占用的内存空间

`finalize()`一般是释放通过特殊方式分配的内存空间

  1. 利用java的本地方法调用了其他语言来进行内存分配
  2. 要是对象表示一个打开的文件，在对象被回收前，应该利用`finalize()`将文件关闭

在覆盖`finalize()`时，应该要调用父类的`finalize()`，防止丢失父类的清理过程

### `gc()`

用于催促垃圾回收器执行垃圾回收，但是垃圾回收器不一定会进行垃圾回收
