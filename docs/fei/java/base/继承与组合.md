# 继承与组合

## 组合语法

只需将对象引用放到新类中

组合对象初始化的位置

* 定义对象时进行初始化
* 在新类的构造函数中初始化
* 在使用这些组合对象之前进行初始化(惰性初始化)

## 继承语法

继承一般将数据成员指定为`private`，方法指定为`public`

### 初始化父类

1. 创建子类对象实例时，该实例包含一个父类对象，这个父类对象与用父类直接创建的对象是一样的，区别在于，后者创建的对象在外部，前者创建的对象在子类对象实例内部

2. java会自动在子类的构造器中插入对父类构造器的调用，构建过程从子类对象实例中的父类对象向外扩散

3. 如何没有默认的父类构造器或者想调用带参数的父类构造器，就得使用`super`来显式调用

## 代理

java并没有提供对代理的直接支持，这是继承和组合之间的中庸之道，因为我们将一个成员对象放到所要构造的类中(就像组合)，但又在新类中暴露了该成员对象的所有方法(就像继承)

## 组合与继承

1. 组合和继承都在新的类中放置了内部对象，组合是显式地这样做，而继承是隐式地这样做
2. 组合通常用于在新类中使用现有类的功能而非它的方法这种情况
3. 继承通常用于将一个通用类进行特殊需求的定制化实现
4. `is a`关系用继承来表达，`has a`关系用组合来表达

> 需要子类向父类转型(向上转型)，则用继承，不需要则考虑用组合

## `final`

### `final`数据

1. 编译期常量(`final`且`static`的域)，常用大写字母命名，且字母之间用下划线隔开

    编译期常量，编译器直接将该常量的值代入到任何可能用到它的计算中，这样在编译时就执行了计算，减轻了运行时的负担，在java中，这类常量必须是一些特定的类型，例如基础数据类型等，且以`final`和`static`修饰

2. 运行时常量(`final`但没`static`的域)

**`final`数据必须在定义时或者在构造器中用值或表达式进行赋值初始化**

方法的参数能用`final`来修饰

`final`的作用

* 对基础类型，`final`使数据值不变
* 对引用类型，`final`使引用不变

## `final`方法

1. 防止被继承覆盖
2. `private`方法都隐式指定为`final`，用`final`修饰`private`方法没有实际意义

> `private`方法是类的内部方法，不是类向外暴露的接口的一部分

## `final`类

1. `final`类不能被继承

> 由于`final`类不能被继承，所以`final`类中的所有方法都隐式指定为`final`
