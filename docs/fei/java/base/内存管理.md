# java内存管理

## 运行时数据区(`Runtime Data Area`)

* 堆和方法区是所有线程共享的，所有执行引擎都可以访问
  * 堆(`Heap`)

    用于存储`java`对象实例

  * 方法区(`Method Area`)

    用于存储类结构信息，`.class`文件加载进`jvm`时会被解析成`jvm`能识别的数据，分别存储在不同的数据结构中：运行时常量池、域、方法数据、方法体、构造方法以及初始值

* 虚拟机栈、本地方法栈、程序计数器都是线程私有的，每个执行引擎启动时都会创建自己的虚拟机栈、本地方法栈、程序计数器
  * 虚拟机栈(`VM Stack`)

    每个线程在创建的时候，`jvm`都会为它分配一个对应的虚拟机栈，这个栈含有多个栈帧

    每个方法在运行的时候，都会创建一个自己的栈帧，含有内存变量、操作帧、方法返回值(用于存储方法参数、局部变量、方法返回值和运算的中间结果)

  * 程序计数器(`Program Counter Register`)

    用于记录下一条要执行的字节码指令的地址和被中断的地址，如果方法是`native`的，程序计数器的值不会被定义为空

  * 本地方法栈(`Native Method Stack`)

    为`jvm`运行`native`方法而准备的空间

### 常量池

常量池的数据在编译期就被确定，常量池是`.class`文件的一部分，存储了类、方法、接口中的常量(包括字符串常量)

* 字符串池(字符串常量池)

  常量池的一部分，存储编译期中类产生的字符串数据

* 运行时常量池

  方法区的一部分，所有线程共享，虚拟机加载`.class`文件，把`.class`常量池中的数据加载到运行时常量池中

## 垃圾回收(`Generational Collecting`)

### 基于分代的垃圾回收算法

把对象分为年轻代(`Young`)，年老代(`Tenured`)，持久代(`Perm`)，对不同生命周期的对象使用不同的算法

* 年轻代(`Young`)

  年轻代分为三个区，一个`Eden`区，两个`Survivor`区(`from`区，`to`区)

* 年老代(`Tenured`)

  年老代存放从年轻代中存活下来的对象

  一般年老代存放的都是生命周期较长的对象，`Tenured`区满了就会触发`Full GC`回收整个堆内存

* 持久代(`Perm`)

  持久代用于存放`.class`文件加载出来的数据，垃圾回收是由`Full GC`触发的，持久代对垃圾回收没有显著影响

  在有动态加载`.class`文件需求的时候，需要设置一个比较大的持久代空间来存放这些运行过程中新增的数据

> 通常`jvm`内存垃圾回收指的是堆内存回收，确实只有堆中的内容是动态申请分配的，年轻代和年老代的空间属于堆(`Heap`)，持久代的空间属于方法区(`Method Area`)

### 简单的内存优化

* 没用的对象赋值为`null`，能加快内存回收
* 对象池，提高对象的复用性
* 用`jvm`参数调优

### 标记-清理算法

当堆中的可用有效内存空间(`available memory`)被耗尽的时候，就暂停整个程序(`stop the world`)，然后进行标记和清理，再让程序恢复运行

* 标记阶段

  遍历所有的`GC Roots`，然后将所有`GC Roots`可达的对象标记为存活

* 清理阶段

  遍历堆中所有的对象，将没有标记成存活的对象全部清理掉

缺点

* 递归与遍历堆的所有对象，效率低(遍历两次)，暂停程序(`stop the world`)的时间比较长
* 清理出来的空闲内存不连续

### 复制算法(适合年轻代)

内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存块中存活的对象复制到未使用的内存块中，再清理正在使用的内存块中的所有对象，交换两个内存块的角色，再让程序恢复运行

优点

* 实现简单，运行高效，内存连续

缺点

* 浪费空间，只使用了一半的内存空间

复制算法适合年轻代，年轻代中的对象的存活率很低，`98%`的对象都是朝生夕死的，所以不需要按照`1:1`的比例来划分内存空间，而是将内存分为一块比较大的`Eden`区和两块较小的`Survivor`区，每次只使用`Eden`区和其中一块`Survivor`区，当回收时，将`Eden`区和`Survivor`区中还存活的对象一次性地复制到另外一块`Survivor`区上，如果另外一块`Survivor`区的内存空间不够用，那么较大的对象会直接进入年老代(`Perm`)，最后清理`Eden`区和原来`Survivor`区的内存空间

`HotSpot JVM`默认`Eden`区和`Survivor`区的大小比例是`8:1`，即每次年轻代中可用的内存空间为整个年轻代内存空间的`90%(80%+10%)`，只有`10%`的空间会被浪费

### 标记-整理算法(适合年老代)

遍历所有的`GC Roots`，然后将所有`GC Roots`可达的对象标记为存活，然后将所有存活的对象压缩到内存的一端，最后清理末端后面所有的内存空间，再让程序恢复运行

* 标记阶段

  遍历所有的`GC Roots`，然后将所有`GC Roots`可达的对象标记为存活

* 整理阶段

  移动所有存活的对象，按照内存地址顺序依次排序，然后清理末端内存地址后的内存空间

优点

* 清理出来的空闲连续
* 充分利用内存空间

缺点

* 递归与遍历堆的所有对象，并且整理所有存活对象的引用地址，效率低(遍历两次)

### 标记-清理、复制、标记-整理三个算法的比较

三个算法都基于根搜索算法去判断一个对象是否应该被回收，而支撑根搜索算法可以正常工作的理论依据是语法中变量作用域的使用是否合理，所以要想防止内存泄漏，最根本的方法就是合理使用变量作用域

在`GC`线程开启时，三个算法都要暂停程序(`stop the world`)

区别

* 效率：复制`>`标记-整理`>`标记-清理
* 内存整齐度：复制`=`标记-整理`>`标记-清理
* 内存利用率：标记-整理`=`标记-清理`>`复制
