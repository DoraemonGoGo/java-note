# 多态

作用：消除类型之间的耦合关系

## 方法绑定

将一个方法调用跟一个方法体关联起来的操作被称为绑定

### 前期绑定

在编译时，确定被调用的函数的具体代码的绝对地址

在运行时，直接执行已获地址上面的具体代码(c++等语言默认的模式)

### 后期绑定

在编译时，只确保被调用方法的存在，并对调用参数和返回值的类型进行检查(强类型语言)，用一段特殊的代码替代绝对地址

在运行时，特殊的代码就使用在对象中存储的信息来计算方法体的绝对地址，进而执行地址上的具体代码(java等语言默认的模式)

## 上下转型

```java
class Fruit {
    void say() {
        System.out.println("fruit");
    }
}

class Apple extends Fruit {
    @Override
    void say() {
        System.out.println("apple");
    }
}

public class Test {
    public static void main(String[] args) {
        // 向上转型 子类 -> 父类
        Fruit fruit = new Apple();
        // 调用指向子类实例的父类引用，依然能执行子类实例的方法体(多态性)
        fruit.say();
        // 向下转型 父类 -> 子类
        Apple apple = (Apple) fruit;
        apple.say();
    }
}
```

> 除非知道父类引用实际指向实例的类型，否则向下转型都是不安全的，而向上转型都是安全的

## 方法与多态

java中除了`static`方法和`final`方法(`private`方法属于`final`方法)之外的方法都是后期绑定

`final`方法除了可以防止方法被覆盖，还可以关闭后期绑定

## 域与多态

任何域的访问操作都由编译器解析，因此都不是多态的

## 构造器内部的多态行为

在任何构造器内部，整个对象可能只是部分形成，只保证了父类对象已经进行了初始化

在构造器中应该尽量少用多态行为，非要调用方法，可使用前期绑定的方法(`static`，`final`，`private`)

## 协变返回类型

`Java SE5`允许同一个方法，子类方法返回类型是父类方法返回类型的子类，无需类型完全一致

## 继承关系

* 纯继承(`is-a`关系)：子类和父类具有一样的接口
* 扩展继承(`is-like-a`关系)：子类不仅有父类一样的接口，还有额外扩展的接口(不能被父类引用访问)
