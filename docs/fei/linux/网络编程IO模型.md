# socket读操作

一个socket上的读操作包含了两个阶段

1. 等待数据准备好
2. 将数据从内核拷贝到用户进程缓冲区

## 阻塞式IO(blocking IO)

默认情况下，linux中的所有socket读操作都是阻塞的

用户进程调用`recvfrom`函数一直阻塞，直到数据报准备好且已拷贝到用户进程缓冲中为止，或者中途发生错误(被信号中断)才返回

特点：socket读操作的阶段1和阶段2都被阻塞

## 非阻塞式IO(non-blocking IO)

**linux下通过`fcntl`函数将socket设置为非阻塞模式**

用户进程在内核数据还没准备好的时候，会不断调用`recvfrom`函数，`recvfrom`函数会立刻返回`EWOULDBLOCK`错误，因此用户进程不会阻塞，当数据报准备好时，用户进程会阻塞直到内核把数据拷贝到用户进程缓冲区中为止

特点：socket读操作的阶段1不阻塞，阶段2阻塞

## IO复用(IO multiplexing), 事件驱动IO(event-driven IO)

单个线程同时监控多个socket，通过`select/poll`函数轮询所有的socket，当某个socket可读时，通知用户进程调用`recvfrom`函数

用户进程阻塞在`select/poll`函数上，当某个socket可读时，用户进程阻塞在`recvfrom`函数上，直到内核把数据拷贝到用户进程缓冲区为止

特点：socket读操作的阶段1和阶段2都被阻塞，但是阶段1是被`select/poll`函数阻塞，阶段2是被`recvfrom`函数阻塞

## 信号驱动式IO(signal-driven IO)

让内核在数据报准备好时发送`SIGIO`信号通知用户进程

开启socket的信号驱动式IO功能，通过`sigaction`系统调用注册`SIGIO`信号处理函数，该系统调用会立即返回

当数据报准备好时，内核会产生`SIGIO`信号，这时就可以在信号处理函数中调用`recvfrom`函数让内核拷贝数据到用户进程缓冲区中

特点：socket读操作的阶段1不阻塞，阶段2阻塞，即收到`SIGIO`信号后才阻塞

## 异步IO(asynchronous IO)

用户进程在进行`aio_read`系统调用后，会立即返回，然后内核会自己等待数据报准备好并把数据报拷贝到用户进程缓冲区中，整个过程完成后，内核才会给用户进程发送一个信号，通知IO操作已完成

> 异步IO与信号驱动式IO的主要区别：信号驱动式IO是由内核通知我们何时启动一个IO操作，而异步IO是由内核通知我们IO操作何时完成

特点：socket读操作的阶段1和阶段2都不阻塞

## 五种IO模型的比较

* 阻塞式IO
* 非阻塞式IO
* IO复用
* 信号驱动式IO
* 异步IO

前面4种模型主要区别在于第一阶段，因为它们的第二阶段是一样的(都是阻塞于`recvfrom`调用，将数据报从内核拷贝到用户进程缓冲区中)

## 阻塞IO与非阻塞IO

阻塞IO：会一直阻塞用户进程直到IO操作完成

非阻塞式IO：在内核的数据报还没准备好的时候会立即返回，不会阻塞

## 同步IO与异步IO

同步IO：导致用户进程阻塞，直到IO操作完成

异步IO：不会导致用户进程阻塞

## 真正的IO系统调用

> recvfrom

阻塞式IO模型，非阻塞式IO模型，IO复用模型，信号驱动式IO模型都属于同步IO

异步IO模型属于异步IO
