## 方法重载

### 什么是方法重载？为什么不能根据返回类型来区分重载？

方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。

重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载。为什么这里不包括返回类型呢？很简单，如果只是返回类型不同，是无法区分开来的，如下：
<!--more-->
```java
float max(int a, int b);
int max(int a, int b);
```

在调用上述两个方法的时候，可以不用返回值，那么你怎么区分调用的是哪个方法？

在《深入理解Java虚拟机》中，6.3.6章节有这样一段：
>在Java语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名；
>
>特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载。
>
>但在Class文件格式之中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以共存。
>
>也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法存于同一个Class文件中的。

### Class文件中同方法名、同参数、不同返回值可以，那为什么Java文件中不行呢？

因为Java语言规范的规定，所以编译时会出现错误。

那为什么Class文件可以呢？因为Java虚拟机规范和Java语言规范不同，两者是分开的。

如有更多兴趣，可以看看这篇文章：[Java语言层面和JVM层面方法特征签名的区别 及 实例分析](https://blog.csdn.net/tjiyu/article/details/53891813)

## 三元运算符隐含的坑

### 三元表达式导致的空指针异常

某天发现系统报空指针异常，追踪异常栈后发现源头处是一个非常简单的三元表达式，如下：
```java
Integer age = user != null ? user.getAge() : 0;
```

咋看上去好像看不出什么问题，然而当user对象里的age变量为null时，就会触发NPE。原因是三元表达式的其中一条表达式的返回值为基础数据类型时，如果另一个表达式的返回值是包装类，则会自动拆箱。

比如这里的`user.getAge()`返回的是`Integer`，由于另一个表达式是0，当`user != null`是true的时候，左边的表达式就变成了`user.getAge().intValue()`，如果user对象里的age变量为null时，就会触发NPE。

如果想避免三元表达式由于拆箱导致的NullPointerException，可以改成如下：
```java
Integer age = user != null ? user.getAge() : new Integer(0);
```

### 三元表达式的隐式类型转换

三元表达式除了会根据另一个表达式的返回值来推断是否进行拆箱，还会和`+=`等操作符一样进行隐式类型转换，数值类型的返回值会自动向高精度转换，如下：
```java
char a = 'a';
int i = 96;

System.out.println(3 >= 2 ? a : 9.0);
System.out.println(3 >= 2 ? i : 9.0);
System.out.println(3 >= 2 ? a : i);
System.out.println(3 >= 2 ? i : a);
System.out.println(3 >= 2 ? 98 : a);
System.out.println(3 >= 2 ? 98 : i);
```

上述的结果如下：
```java
97.0
96.0
a
`
b
98
```

以上结果基于jdk8，另外对于char和int的加法等运算，运算结果会自行转为int类型；**但是在三元表达式中两个表达式返回值分别为char和int时，若返回int类型返回值会转型为char。**

## 静态代码块、构造代码块和代码块

### 静态代码块

```java
static{
	//do something
}
```

静态代码块如上所示，和静态变量、静态方法一样，在类被类加载器首次加载时被执行，之后就不会被再次执行了(除非类加载器卸载该类后重新加载这个类)。

当有多个静态代码块时按顺序执行。

### 构造代码块

```java
public class Test{
	{
		//do something
	}
}
```

和静态代码块类似，但是没有`static`，只能出现在类中，若出现在某个方法中则是普通代码块。

构造代码块会在new实例对象时，优先于构造方法调用，也就是说，先执行完构造代码块，才会接着执行构造方法。如果在一个构造方法里调用了另一个构造方法，此时构造代码块只会被执行一次，而不是执行两次。

当有多个构造代码块时按顺序执行。

### 代码块

```java
public class Test{
	public static void main(String[] args){
		{
			//do something
		}
	}
}
```

和构造代码块类似，但是只在方法或语句中出现，执行顺序和普通语句一样，先出现就先执行。

局部代码块是为了缩短变量的生命周期，定义在局部代码块中的变量在出了代码块之后就结束其生命周期，释放内存。

### 总结

执行顺序：（优先级从高到低）

>静态代码块>main方法>构造代码块>构造方法

其中静态代码块只执行一次，构造代码块在每次创建对象是都会执行。

下面是一道与之相关的题目，执行下边的Test类，其输出的结果是什么？

```java
public class Test{
	static Test test = new Test(1);

	static{
		System.out.println("static code block");
	}

	{
		System.out.println("constructor code block");
	}

	Test(){
		System.out.println("constrctor method");
		System.out.println("a=" + a + ",b=" + b);
		a++;
		b++;
	}

	Test(int a){
		this();
		this.a = a;
		System.out.println("constrctor method2");
		System.out.println("a=" + a + ",b=" + b);
	}

	public static void main(String[] args){
		{
			System.out.println("code block");
		}

		method();

		Test test2 = new Test();
		method();
	}

	public static void method(){
		System.out.println("static method");
	}

	int a = 10;
	static int b = 100;
}
```

答案如下：

```java
constructor code block
constrctor method
a=10,b=0
constrctor method2
a=1,b=1
static code block
code block
static method
constructor code block
constrctor method
a=10,b=100
static method
```

## long、float、double变量的L、F、D尾缀和类型转换问题

在声明long、float、double变量的时候，往往会在字面量末尾加上对应的L、F、D，也可以是小写的l、f、d，一般long变量尽量用大写的L，避免和数字的1和大写的i混淆。如下：
```java
long a = 123L;
float b = 1.23F;
double c = 1.23D;
```

等号右边的数值叫做字面量`literal`，跟在字面量末尾的字母是为了告诉编译器数值的类型。有时候不添加尾缀，编译期也不会报错，因为整数型的字面量默认是int，浮点型的字面量默认是double，如下：
```java
long a = 123;
double c = 1.23;
```

这里不会在编译期报错，是因为范围小的类型可以自动转换成范围大的类型，因为不会丢失精度，也叫向上转型。而`float b = 1.23;`会报错，是因为`1.23`默认是double类型，精度比float大，无法自动转换类型，需要进行强制类型转换，即`float b = (float) 1.23;`。

long的字节数是8，和float字节数一样，但是`long b = 1.23f;`还是会报错。这是因为long和float的存储方式不一样，尽管二者占据一样多的字节，但是float能表示的数值范围远超long，所以需要强制类型转换：`long b = (long) 1.23f;`。

**既然不能直接将字面量赋值给精度更小的类型，那为什么`byte b = 12; short s = 12;`却不需要强制类型转换也不会报错？**

这是因为编译器对整数型数值做了处理，对于整数字面量，如果赋值给比int范围更小的类型时（即byte/char/short类型），如果该字面量没有超出对应的赋值类型的范围，就会自动进行隐式类型转换。如果超出了范围，就会报错，需要经过强制类型转换才可以。

**为什么`byte b = 100`不会报错，而`int a = 100; byte b = a;`却会报错？**

前者是因为100属于byte的范围内，会隐式类型转换。后者的变量a已经被声明为int类型，将其直接赋值给byte变量需要经过强制类型转换：`int a = 100; byte b = (byte) a;`

## 参考链接

* [深入 -- 为什么不能根据返回类型来区分重载？](https://blog.csdn.net/simba_cheng/article/details/80835646)
* [java三元运算符详解](https://www.cnblogs.com/itmlt1029/p/4756331.html)
* [Java中三元运算符值得注意的地方](https://blog.csdn.net/shikaiwencn/article/details/50443495)
* [Java中给byte变量直接赋值可以自动转换,但为什么把int变量赋给byte变量需要强制转换，同样是int。](https://zhidao.baidu.com/question/878702194900509172.html)
* [Java中float、double、long类型变量赋值添加f、d、L尾缀问题](https://blog.csdn.net/FX677588/article/details/52663805)