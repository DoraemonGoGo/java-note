<!--
date: 2021-04-15T23:31:12+08:00
lastmod: 2021-04-15T23:31:12+08:00
-->
## Object基类

Object是所有对象类型的基类（即父类），即使不在类中声明父类，也默认继承了Object类。

Object类中有以下方法：
```java
public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native Class<?> getClass()

protected void finalize() throws Throwable {}

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException
```

### equals()

equals方法用以判断两个对象是否相等，需要满足以下特性：
```java
//自反性
a.equals(a);  //true

//对称性
a.equals(b) == b.equals(a);  //true

//传递性
if (a.equals(b) && b.equals(c))
    a.equals(c);  //true;

//一致性，即多次调用equals()方法结果不变
a.equals(b) == a.equals(b);  //true

//与null的比较为false
a.equals(null);  //false，a不能为null，否则抛出NullPointerException
```

Object类中equals方法实现很简单：
```java
public boolean equals(Object obj) {
    return (this == obj);
}
````

`==`是比较两个对象的内存地址（对于基本数据类型是直接比较值是否相等），如果是两个不同的对象，则必然返回false。可以通过重写该方法来根据需要判断两个对象是否等价，比如Integer类就重写了该方法：
```java
public boolean equals(Object obj) {
    if (obj instanceof Integer) {
        return value == ((Integer)obj).intValue();
    }
    return false;
}
```

### hashCode()

hashCode()是本地方法（调用的是操作系统的库函数），用以计算哈希值，两个等价的对象其哈希值必定是相同的，但是哈希值相同的两个对象不一定等价。因为哈希算法的缘故，存在哈希冲突的可能性，两个不同的对象是有可能计算出相同哈希值的。

一般在重写equals方法时，要求一起重写hashCode方法，以保证等价的两个对象哈希值也相等。比如Integer类，就同时重写了equals和hashCode方法。

在使用HashSet和HashMap等容器时，这些容器类使用了hashCode方法来计算对象的存储位置，因此被添加进这些容器的对象需要根据实际需求来重写hashCode方法。比如两个等价的对象，由于没重写hashCode方法，就可能导致被重复添加到HashSet中。

### getClass()

同样是本地方法，获取当前类的类对象，一般用于反射。

### toString()

```java
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

默认实现是返回类名、`@`以及哈希码的十六进制字符串拼接起来的String。

## 方法重载

### 什么是方法重载？为什么不能根据返回类型来区分重载？

方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。

重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载。为什么这里不包括返回类型呢？很简单，如果只是返回类型不同，是无法区分开来的，如下：

```java
float max(int a, int b);
int max(int a, int b);
```

在调用上述两个方法的时候，可以不用返回值，那么你怎么区分调用的是哪个方法？

在《深入理解Java虚拟机》中，6.3.6章节有这样一段：
>在Java语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名；
>
>特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载。
>
>但在Class文件格式之中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以共存。
>
>也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法存于同一个Class文件中的。

### Class文件中同方法名、同参数、不同返回值可以，那为什么Java文件中不行呢？

因为Java语言规范的规定，所以编译时会出现错误。

那为什么Class文件可以呢？因为Java虚拟机规范和Java语言规范不同，两者是分开的。

如有更多兴趣，可以看看这篇文章：[Java语言层面和JVM层面方法特征签名的区别 及 实例分析](https://blog.csdn.net/tjiyu/article/details/53891813)

## 参考链接

* [五、Object 通用方法](http://cyc2018.gitee.io/cs-notes/#/notes/Java%20基础?id=%e4%ba%94%e3%80%81object-%e9%80%9a%e7%94%a8%e6%96%b9%e6%b3%95)
* [深入 -- 为什么不能根据返回类型来区分重载？](https://blog.csdn.net/simba_cheng/article/details/80835646)