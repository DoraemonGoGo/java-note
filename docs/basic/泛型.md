<!--
date: 2021-04-19T22:34:12+08:00
lastmod: 2021-04-26T22:34:12+08:00
-->
## 泛型（Generic）

泛型：把类型明确的工作推迟到创建对象或调用方法时再明确的特殊类型。

参数化类型：把类型当作参数来传递，这意味着参数化类型不能是基本数据类型，需要用对应的包装类来代替。

相关概念：

* `ArrayList<E>`中的`E`是类型参数变量（typeVariable，也叫泛型参数），除了E之外，也可以是任意标识符。其实就是一个变量名，常用的一般有E（Element）、T（Type）、K（Key）、V（Value）等。
* `ArrayList<Integer>`中的`Integer`称为实际类型参数，上面的`E`相当于形参，这里的`Integer`相当于实参
* `ArrayList<E>`整个被称为泛型类型（泛型类）
* `ArrayList<Integer>`整个被称为参数化的类型（ParameterizedType）

只有声明了泛型参数的类才是泛型类（泛型接口同理），只有声明了泛型参数的方法才是泛型方法。也就是说，泛型类中使用了泛型的方法并不是泛型方法，泛型类声明的泛型参数和泛型方法声明的泛型参数可以重名，但是二者并不存在任何关系。

```java
// 泛型类
class TestGeneric<T> {

    // 不是泛型方法
    public T getT1(T t) {
        return t;
    }
    
    // 泛型方法，这里的T和泛型类的T完全没有关系
    public <T> T getT2(T t) {
        return t;
    }

}

// 不是泛型类
class TestGeneric2<Integer> {

    // 不是泛型方法
    public Integer getT1(Integer t) {
        return t;
    }
    
	// 泛型方法
    public <T> T getT2(T t) {
        return t;
    }

}
```

泛型是在类实例化或者方法调用时才明确类型的：
* 对于泛型类的泛型参数，需要在类实例化时才能明确类型；
* 对于泛型方法的泛型参数，需要在方法调用时才能明确类型。

## 泛型的好处

* 泛型的本质是为了参数化类型，在不创建新类型的情况下，通过泛型指定的不同类型来限制形参的具体类型，以此提高代码的复用性。
* 安全性。泛型可以在编译时检测类型安全，避免在运行时发生类转换异常ClassCastException。
* 可读性，代码更加简洁。泛型会进行隐式类型转换，比如在使用集合时，无需进行强制类型转换。比如遍历一个指定了泛型的集合时，就可以用增强for来进行遍历。

## 类型擦除

Java的泛型是伪泛型。泛型是提供给javac编译器使用的，在编译期间，所有的泛型信息会被擦除掉，生成的class文件中将不再带有泛型信息。

泛型只是在编译期生效，所以可以通过反射往一个泛型特性的集合中加入限制类型以外的元素。尽管存在着类型擦除，但如果一个类声明了类型参数变量，依然可以用反射`getTypeParameters()`来获取该类型变量。

Java是向前兼容的，泛型在Java5引入，需要兼容Java5之前的版本。

## 不能使用泛型的场景

### 基本类型不能使用泛型

泛型的类型参数要求是Object的子类，所以不能使用基本数据类型，只能使用对应的包装类。

```java
List<int> list = new ArrayList<>();  // Syntax error, insert "Dimensions" to complete ReferenceType

List<Integer> list = new ArrayList<>();  // ok
```

### 泛型类型无法直接实例化

由于泛型擦除的原因，运行期泛型信息是不可见的，因此不能直接实例化。

```java
public <E> void test(E e) {
    E e2 = new E();  // Cannot instantiate the type E
}
```

### 泛型类的泛型参数不能作为静态变量，也不能作为静态方法的返回值

泛型类在类实例化时才明确类型，而静态类型是在类加载时就初始化的，此时对于泛型类是无法明确泛型的具体类型的，所以泛型类的泛型参数不能作为静态变量。也就是说，泛型类的泛型参数默认就是非静态的。

但是，对于泛型方法，则可以被定义为静态的。原因是泛型方法在方法调用时明确类型，与类实例化无关，所以允许定义为静态的。

```java
class TestGeneric<T> {

    T t1;  // ok
    
    static T t2;  // Cannot make a static reference to the non-static type T
    
    static {
        T t3;  // Cannot make a static reference to the non-static type T
    }

    public static T getT(T t) {  // Cannot make a static reference to the non-static type T
        return t;
    }

    public static <E> E getE(E e) {  // ok
        return e;
    }
    
}
```

### 无法进行 instanceof 判断

Java的泛型是伪泛型，在编译期会被擦除，运行的字节码中不存在泛型，所以下面的判断条件无法进行：

```java
class TestGeneric<T> {

    public void test(ArrayList<T> list) {
        // Cannot perform instanceof check against parameterized type ArrayList<Integer>. 
        // Use the form ArrayList<?> instead since further generic type information will be erased at runtime
        if (list instanceof ArrayList<Integer>) {
            return;
        }
    }

    public <E> void getE(ArrayList<E> list) {
        // 报错同上
        if (list instanceof ArrayList<Integer>) {
            return;
        }
    }

}
```

但是泛型的无界通配符`<?>`可以进行`instanceof`判断。

## 参考链接

* [九、泛型](http://cyc2018.gitee.io/cs-notes/#/notes/Java%20%E5%9F%BA%E7%A1%80?id=%e4%b9%9d%e3%80%81%e6%b3%9b%e5%9e%8b)
