<!--
date: 2021-04-19T22:34:12+08:00
lastmod: 2021-04-29T22:34:12+08:00
-->
## 泛型（Generic）

泛型：把类型明确的工作推迟到创建对象或调用方法时再明确的特殊类型。

参数化类型：把类型当作参数来传递，这意味着参数化类型不能是基本数据类型，需要用对应的包装类来代替。

相关概念：

* `ArrayList<E>`中的`E`是类型参数变量（typeVariable，也叫泛型参数），除了E之外，也可以是任意标识符。其实就是一个变量名，常用的一般有`E（Element）、T（Type）、K（Key）、V（Value）`等。
* `ArrayList<Integer>`中的`Integer`称为实际类型参数（ActualTypeArgument），上面的`E`相当于形参，这里的`Integer`相当于实参
* `ArrayList<E>`整个被称为泛型类型（泛型类，GenericType）
* `ArrayList<Integer>`整个被称为参数化的类型（ParameterizedType）
* `ArrayList`被称为原生类型（RawType）

## 泛型的好处

* 泛型的本质是为了参数化类型，在不创建新类型的情况下，通过泛型指定的不同类型来限制形参的具体类型，以此提高代码的复用性。
* 安全性。泛型可以在编译时检查类型安全，避免在运行时发生类转换异常ClassCastException。
* 可读性，代码更加简洁。泛型会进行隐式类型转换，比如在使用集合时，无需进行强制类型转换。比如遍历一个指定了泛型的集合时，就可以用增强for来进行遍历。

## 泛型类、泛型方法

只有声明了泛型参数的类才是泛型类（泛型接口同理），只有声明了泛型参数的方法才是泛型方法。也就是说，泛型类中使用了泛型的方法并不是泛型方法，**泛型类声明的泛型参数和泛型方法声明的泛型参数可以重名，但是二者并不存在任何关系。**

```java
// 泛型类
class TestGeneric<T> {

    // 不是泛型方法
    public T getT1(T t) {
        return t;
    }
    
    // 泛型方法，这里的T和泛型类的T完全没有关系
    public <T> T getT2(T t) {
        return t;
    }

}

// 不是泛型类
class TestGeneric2<Integer> {

    // 不是泛型方法
    public Integer getT1(Integer t) {
        return t;
    }
    
	// 泛型方法
    public <T> T getT2(T t) {
        return t;
    }

}
```

泛型是在类实例化或者方法调用时才明确类型的：
* 对于泛型类的泛型参数，需要在类实例化时才能明确类型；
* 对于泛型方法的泛型参数，需要在方法调用时才能明确类型。

如果要继承泛型类，写法如下：

```java
// 定义一个泛型类
class TestGeneric<T> {

}

// 定义一个参数化类型
class TestChild extends TestGeneric<Integer> {

}

// 定义一个泛型类子类，子类必须声明泛型参数，否则编译报错
class TestChild2<T> extends TestGeneric<T> {

}
```

实现泛型接口的写法也是同理。

## 泛型原理：类型擦除

Java的泛型是伪泛型。泛型是提供给javac编译器使用的，在编译期间，所有的泛型信息会被擦除掉，生成的class文件中将不再带有泛型信息。

Java是向前兼容的，泛型在Java5引入，需要兼容Java5之前的版本，这也是Java泛型需要类型擦除的原因之一。

在编译期，`ArrayList<Integer>`和`ArrayList`对于编译器是两个不同的类型；但是经过了泛型擦除后，在运行期，对于JVM来说就是一样的类型。

## 泛型通配符

泛型参数除了可以是Java标识符之外，还可以指定为`?`无界通配符，用以表示不确定的Java类型。

但是`?`不可用于声明泛型，只能用于使用泛型的场合。因为`?`并不是合法的Java标识符，并不能作为泛型参数的名字，只能作为数据类型参数来使用，效果相当于Object。

```java
// 不能用通配符声明泛型类
class TestGeneric<?> {  // Syntax error on token "?", Identifier expected

    // 不能用通配符声明泛型方法
    public <?> void test1(final ? test) {  // Syntax error on token "?", byte expected

    }
    
    public void test2(final List<?> test) {  // ok
        
    }
}
```

### 无界通配符`<?>`

泛型使用最多的场景是集合，然而对于泛型集合来说，每个集合之间都是完全独立的：

```java
class Animal {

    private String name;

    public Animal(final String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return name;
    }
}

class Dog extends Animal {

    public Dog(final String name) {
        super(name);
    }
}

class TestGeneric {

    public static void main(final String[] args) {
        List<Dog> dogs = new ArrayList<>();
        List<Animal> animals = new ArrayList<>();
        // 编译错误
        dogs = animals; // Type mismatch: cannot convert from List<Animal> to List<Dog>
        // 编译错误
        animals = dogs; // Type mismatch: cannot convert from List<Dog> to List<Animal>
        
		// 在运行期这两个泛型集合的类型是同一个类对象
        System.out.println(dogs.getClass() == animals.getClass());  // true
        
        // 不能添加Animal对象
        dogs.add(new Animal("animal"));  // The method add(Dog) in the type List<Dog> is not applicable for the arguments (Animal)
        dogs.add(new Dog("dog"));  // ok
        
        animals.add(new Animal("animal"));  // ok
        animals.add(new Dog("dog"));  // ok
    }
}
```

可以看到，虽然`Dog`是`Animal`的子类，但是`List<Animal>`和`List<Dog>`这两个集合之间并不存在任何关系，不能把一个`List<Dog>`对象直接赋值给一个`List<Animal>`引用。于是这就会引发一个问题，如果一个方法的参数是泛型集合，就很容易出现类型不匹配的情况。为了避免这种情况，也更有利于代码的复用和简洁，就有了无界通配符`<?>`，如下：

```java
class TestGeneric {

    public static void test1(final List<Animal> list) {
        list.forEach(each -> System.out.println(each));
    }

    public static void test2(final List<?> list) {
        list.forEach(each -> System.out.println(each));
    }

    public static void main(final String[] args) {
        List<Dog> dogs = new ArrayList<>();
        List<Animal> animals = new ArrayList<>();
        List<?> list = new ArrayList<>();

        // 编译错误，无法调用
        test1(dogs);    // The method test1(List<Animal>) in the type TestGeneric is not applicable for the arguments (List<Dog>)
        test1(animals); // ok
        // 编译错误，无法调用
        test1(list);    // The method test1(List<Animal>) in the type TestGeneric is not applicable for the arguments (List<capture#2-of ?>)
        
        test2(dogs);    // ok
        test2(animals); // ok
        test2(list);    // ok

        dogs.add(new Dog("DogA"));	// ok
        // 编译错误
        list.add(new Animal("animal")); // The method add(capture#2-of ?) in the type List<capture#2-of ?> is not applicable for the arguments (Animal)
        // 编译错误
        list.add(new Dog("dog"));   // The method add(capture#3-of ?) in the type List<capture#3-of ?> is not applicable for the arguments (Dog)
        list.add(null); // ok

        list = dogs;
        // 将泛型通配符集合赋值为普通的泛型集合后，依然不能添加null以外的元素
        list.add(new Dog("dog"));   // The method add(capture#6-of ?) in the type List<capture#6-of ?> is not applicable for the arguments (Dog)

    }
}
```

可以发现，泛型通配符集合虽然被任意的泛型集合对象所赋值，但是却不能往这个集合里添加null以外的任何元素，只能读取这个集合的元素，并且被读取的元素必须转型为Object类型。

### 上界通配符`<? extends T>`



### 下界通配符`<? super T>`



### PECS原则



## 泛型数组




## 泛型与反射

泛型的类型检查只是在编译期生效，所以可以在运行期通过反射往一个泛型集合中加入限制类型以外的元素。

由于泛型擦除的原因，虽然无法在运行期通过反射动态获取一个泛型类的实际类型，但依然可以用反射来获取参数化类型的泛型信息。**注意，泛型类和参数化类型不是一个东西。**

* [Java中的泛型会被类型擦除，那为什么在运行期仍然可以使用反射获取到具体的泛型类型？](https://www.zhihu.com/question/346911525/answer/830285753)

```java
class TestGeneric<T> {

    public TestInner child;

    public static void main(final String[] args) {
        final TestChild testChild = new TestChild();
        testChild.child = testChild.new TestInner();
        testChild.getArray(testChild, 3);
        System.out.println("===============================");
        testChild.getArray(testChild.child, 3);
    }

    class InnerGeneric<E> {

    }

    class TestInner extends InnerGeneric<Integer> {

    }

}

class TestChild extends TestGeneric<Integer> {

    public Integer[] getArray(final Object obj, final int length) {
      final ParameterizedType type = (ParameterizedType) obj.getClass().getGenericSuperclass();
      final Class <?> clazz = (Class <?>) type.getActualTypeArguments()[0];
      System.out.println("Class: " + obj.getClass().getName());
      System.out.println("ParameterizedType: " + type.getTypeName());
      System.out.println("RawType: " + type.getRawType());
      System.out.println("OwnerType: " + type.getOwnerType());
      System.out.println("ActualTypeArguments' number: " + type.getActualTypeArguments().length);
      System.out.println("ActualTypeArgument Class: " + clazz.getName());
      return (Integer[])Array.newInstance(clazz, length);
  }

}
```

运行结果如下：

```java
Class: test.TestChild
ParameterizedType: test.TestGeneric<java.lang.Integer>
RawType: class test.TestGeneric
OwnerType: null
ActualTypeArguments' number: 1
ActualTypeArgument Class: java.lang.Integer
===============================
Class: test.TestGeneric$TestInner
ParameterizedType: test.TestGeneric<T>.InnerGeneric<java.lang.Integer>
RawType: class test.TestGeneric$InnerGeneric
OwnerType: test.TestGeneric<T>
ActualTypeArguments' number: 1
ActualTypeArgument Class: java.lang.Integer
```

如果理解了前文提及的相关概念，那么自然也能理解这些泛型反射的方法。

## 不能使用泛型的场景

### 基本类型不能使用泛型

泛型的类型参数要求是Object的子类，所以不能使用基本数据类型，只能使用对应的包装类。

```java
List<int> list = new ArrayList<>();  // Syntax error, insert "Dimensions" to complete ReferenceType

List<Integer> list = new ArrayList<>();  // ok
```

### 泛型类型无法直接实例化

由于泛型擦除的原因，运行期泛型信息是不可见的，因此不能直接实例化。

```java
// 运行期不存在这个泛型E，所以无法实例化
public <E> void test(E e) {
    E e2 = new E();  // Cannot instantiate the type E
}
```

### 泛型类的泛型参数不能作为静态变量，也不能作为静态方法的返回值

泛型类在类实例化时才明确类型，而静态类型是在类加载时就初始化的，此时对于泛型类是无法明确泛型的具体类型的，所以泛型类的泛型参数不能作为静态变量。也就是说，泛型类的泛型参数默认就是非静态的。

但是，对于泛型方法，则可以被定义为静态的。原因是泛型方法在方法调用时明确类型，与类实例化无关，所以允许定义为静态的。

```java
class TestGeneric<T> {

    T t1;  // ok
    
    static T t2;  // Cannot make a static reference to the non-static type T
    
    static {
        T t3;  // Cannot make a static reference to the non-static type T
    }

    public static T getT(T t) {  // Cannot make a static reference to the non-static type T
        return t;
    }

    public static <E> E getE(E e) {  // ok
        return e;
    }
    
}
```

### 无法进行 instanceof 判断

Java的泛型是伪泛型，在编译期会被擦除，运行的字节码中不存在泛型，所以下面的判断条件无法进行：

```java
class TestGeneric<T> {

    public void test(ArrayList<T> list) {
        // Cannot perform instanceof check against parameterized type ArrayList<Integer>. 
        // Use the form ArrayList<?> instead since further generic type information will be erased at runtime
        if (list instanceof ArrayList<Integer>) {
            return;
        }
    }

    public <E> void getE(ArrayList<E> list) {
        // 报错同上
        if (list instanceof ArrayList<Integer>) {
            return;
        }
    }

}
```

但是泛型的无界通配符`<?>`可以进行`instanceof`判断。

## 参考链接

* [九、泛型](http://cyc2018.gitee.io/cs-notes/#/notes/Java%20%E5%9F%BA%E7%A1%80?id=%e4%b9%9d%e3%80%81%e6%b3%9b%e5%9e%8b)
