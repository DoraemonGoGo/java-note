<!--
date: 2022-02-20T22:34:12+08:00
lastmod: 2022-02-21T22:34:12+08:00
-->
## 数据类型

### 整型

TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT分别使用8，16，24，32，64位存储空间，一般情况下越小的列越好。

TINYINT(2)中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。当字符超过规定的数字，则没有意义；当字符少于规定的数字，如果有设置zerofill，那么在显示时就会自动对其用0补齐，比如将1补齐为01。当然在存储时该设置无效。

### 浮点数

FLOAT和DOUBLE为浮点类型，DECIMAL为高精度小数类型。CPU原生支持浮点运算，但是不支持DECIMAl类型的计算，因此DECIMAL的计算比浮点类型需要更高的代价。

FLOAT、DOUBLE和DECIMAL都可以指定列宽，例如`DECIMAL(18, 9)`表示总共18位，取9位存储小数部分，剩下9位存储整数部分。

### 字符串

主要分为定长的CHAR和长度可变的VARCHAR。

VARCHAR能够节省空间，因为只需要存储必要的内容。但是在执行UPDATE时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM会将行拆成不同的片段存储，而InnoDB则需要分裂页来使行放进页内。

在进行存储和检索时，会保留VARCHAR末尾的空格，而会删除CHAR末尾的空格。

### 时间和日期

分为与时区无关的DATETIME，以及与时区相关的TIMESTAMP。

DATETIME使用8个字节进行存储，可以保存从1000年到9999年的日期和时间，精度为秒，默认以一种可排序的、无歧义的格式显示DATETIME值，例如`2008-01-16 22:37:08`。

TIMESTAMP和UNIX时间戳相同，保存从1970年1月1日午夜（格林威治时间）以来的秒数，使用4个字节进行存储，因此最大只能表示到2038年。

MySQL提供了`FROM_UNIXTIME()`函数把UNIX时间戳转换为日期，并提供了`UNIX_TIMESTAMP()`函数把日期转换为UNIX时间戳。

默认情况下，如果插入时没有指定TIMESTAMP列的值，会将这个值设置为当前时间。

应该尽量使用TIMESTAMP，因为它比DATETIME空间效率更高。

## 索引

索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

### B+树索引

大多数MySQL存储引擎默认使用B+树作为索引结构。

* [B+树](/all/container_02_数据结构之树?id=b%e6%a0%91)

使用索引进行查询时只需要搜索树，不需要全表扫描，因此效率很高。由于B+树的有序性，所以除了用于查找，还可以用于排序和分组。

可以指定多个列作为索引列，多个索引列共同组成键，即联合索引。

适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

InnoDB的B+Tree索引分为主索引和辅助索引。主索引的叶子节点data域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

辅助索引的叶子节点的data域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

### 哈希索引

哈希索引能以O(1)时间进行查找，但是失去了有序性：

1）无法用于排序与分组；<br>
2）只支持精确查找，无法用于部分查找和范围查找。

InnoDB存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在B+Tree索引之上再创建一个哈希索引，这样就让B+Tree索引具有哈希索引的一些优点，比如快速的哈希查找。

### 全文索引

MyISAM存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

查找条件使用MATCH AGAINST，而不是普通的WHERE。

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB存储引擎在MySQL 5.6.4版本中也开始支持全文索引。Elasticsearch就是使用全文索引的经典产品。

### 空间数据索引

MyISAM存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

必须使用GIS相关的函数来维护数据。

## 索引优化



## 切分

### 水平切分

水平切分又称为Sharding，是将同一个表中的记录拆分到多个结构相同的表中。

当一个表的数据不断增多时，Sharding是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。

### 垂直切分

垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

## Sharding策略

通常指水平切分的方式：

1）哈希取模：hash(key) % N；<br>
2）范围：可以是ID范围也可以是时间范围；<br>
3）映射表：使用单独的一个数据库来存储映射关系。

## Sharding存在的问题

### 事务问题

使用分布式事务来解决，比如XA接口。

### 连接

可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。

### ID唯一性

1）使用全局唯一ID（GUID）<br>
2）为每个分片指定一个 ID 范围<br>
3）分布式ID生成器（如Twitter的Snowflake算法，即雪花算法）

## 复制

### 主从复制

### 读写分离

## 参考链接

* [MySQL](http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html)