<!--
date: 2022-02-26T22:34:12+08:00
lastmod: 2022-03-04T22:34:12+08:00
-->
## 微服务和分布式

分布式的核心在于“拆”。将一个项目的业务按照**水平拆分**或者**垂直拆分**（也叫横向和纵向拆分）成多个模块，将这些模块分开部署（单机或集群部署），模块之间通过RPC通信，这就是分布式。

微服务就是非常微小的服务，可以理解为一种非常细粒度的垂直拆分。但是**微服务不一定需要部署到不同服务器上，也可以在同一个服务器上。**

**分布式架构强调的是服务化以及服务的分散化，微服务则更强调服务的专业化和精细分工**；从实践的角度来看，微服务架构通常是分布式架构，反之则未必成立。所以，选择微服务通常意味着需要解决分布式架构的各种难题。

## 分布式锁

分布式是跨JVM的，因此原本单机下的锁同步方案在分布式场景中是无效的，此时需要使用分布式锁来实现进程间的同步。

阻塞锁（独占锁）可以用互斥量来实现：

1）互斥量为0时表示其他进程在使用锁，此时处于锁定状态。<br>
2）互斥量为1时表示未锁定状态。

1和0可以用一个整型值表示，也可以用某个数据是否存在表示。其实就类似于把AQS底层的state变量存放到某一个地方，分布式场景中的所有服务都能访问到这个共享资源。换言之，如果将state值调大，也可以用来实现共享锁，类似于单机下JUC中的Semaphore。

独占锁可以有如下实现方案：

### 数据库的唯一索引

获得锁时向表中插入一条数据，释放时则删掉。使用数据库提供的唯一索引可以确保该记录不会被重复插入，因此可以保证该锁的独占性。

这种实现非常简单，而且还可以额外存入其他的信息，比如当前锁是被哪个用户、哪个操作、哪个时间段被申请的等业务相关的数据。

但是缺点也很明显：

1）锁没有失效时间，一旦发生异常或者其他原因令锁释放失败，则其他进程永远无法获得该锁。<br>
2）是非阻塞锁，插入失败会直接报错，无法重试。<br>
3）不可重入，已经获得锁的进程也必须重新获取锁。

### Redis的SETNX命令

Redis提供的`SETNX`（set if not exist）命令，可以保证一个键值对只能被设置一次：设置键值对时，若key已存在则设置失败返回0，若key不存在则设置成功返回1。

`SETNX`命令的效果和数据库的唯一索引类似，但是它可以结合`EXPIRE`命令来为键值对设置过期时间，借此实现锁失效的功能。当然，这只是Redis单机下的独占锁实现。

从Redis 2.6.12版本开始，`SET`命令的行为可以通过参数来实现和`SETNX`、`SETEX`和`PSETEX`三个命令的效果。

`SETEX`命令是`SET` + `EXPIRE`，是一个原子性操作，过期时间单位为秒。

`PSETEX`命令和`SETEX`类似，但过期时间单位为毫秒。

* [Redis - SET命令](http://doc.redisfans.com/string/set.html)

### Redis的RedLock算法

使用多个Redis实例来实现分布式锁，保证在发生单点故障时仍然可用。

1）尝试从多个相互独立的Redis实例获取锁<br>
2）计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获得锁，才算成功获得锁<br>
3）如果获得锁失败，就到每个实例上释放锁。

### Zookeeper的有序节点

## 分布式事务

## 参考链接

* [分布式](http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F.html)
* [答疑 | 分布式和微服务的区别？](https://zhuanlan.zhihu.com/p/138645236)
* [分布式服务架构与微服务架构概念的区别与联系是怎样的？](https://www.zhihu.com/question/28253777)
