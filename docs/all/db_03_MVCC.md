<!--
date: 2022-02-20T22:34:12+08:00
lastmod: 2022-02-20T22:34:12+08:00
-->
## 多版本并发控制

多版本并发控制（Multi-Version Concurrency Control，即MVCC），是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。

未提交读隔离级别总是读取最新的数据行，要求很低，无需使用MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用MVCC无法实现。

换言之，MVCC只在提交读和可重复读这两种隔离级别下工作。

## 基本思想

加锁能解决并发执行事务时的数据一致性问题，在实际场景中读操作往往多于写操作，因此引入读写锁来避免不必要的加锁操作：例如读和读之间是兼容的。但是读和写之间仍然是互斥的，而MVCC基于多版本的思想，写操作更新最新的版本快照，而读操作则读取旧版本快照，二者间没有互斥关系，类似于CopyOnWrite的读写分离。

在MVCC中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。

在事务进行读取操作时，MVCC规定只能读取已经提交的快照（一个事务依然可以读取自身未提交的快照），这样就可以避免脏读和不可重复读。

## 版本号

1）**系统版本号SYS_ID**：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。<br>
2）**事务版本号TRX_ID**：事务开始时的系统版本号将作为当前事务的版本号。

## Undo日志

MVCC的多版本指的是多个版本的快照，快照存储在Undo日志中，该日志通过回滚指针`ROLL_PTR`把一个数据行的所有快照连接起来。

快照中除了记录事务版本号TRX_ID和事务的操作之外，还记录了一个bit的`DEL`字段，用于标记数据行是否被删除。在MVCC中，DELETE操作可以看成是一个特殊的UPDATE，会额外将DEL字段设置为 1。

## 隐藏字段

InnoDB存储引擎在每行数据的后面添加了三个隐藏字段：

### DB_TRX_ID

占据6个字节，表示最近一次对本记录行作出了修改（DELETE、INSERT、UPDATE）的事务ID

### DB_ROLL_PTR

占据7个字节，回滚指针，指向当前记录行的Undo日志的信息

### DB_ROW_ID

占据6个字节，随着新行插入而单调递增的行ID

## ReadView

MVCC维护了一个ReadView结构，用于可见性判断，主要包含了当前系统未提交的事务列表`TRX_IDs{TRX_ID_1, TRX_ID_2, ...}`，还有该列表的最小值`TRX_ID_MIN`和`TRX_ID_MAX`。

在进行SELECT操作时，根据数据行快照的TRX_ID与TRX_ID_MIN和TRX_ID_MAX之间的关系，从而判断数据行快照是否可以使用：

1）TRX_ID < TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。<br>
2）TRX_ID > TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。<br>
3）TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX，需要根据隔离级别再进行判断：<br>
&nbsp;&nbsp;&nbsp;&nbsp;● 提交读：如果TRX_ID在TRX_IDs列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。反之则可以使用。<br>
&nbsp;&nbsp;&nbsp;&nbsp;● 可重复读：都不可以使用。因为如果可以使用的话，则其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，即会出现不可重复读问题。

在数据行快照不可使用的情况下，需要沿着Undo Log的回滚指针找到下一个快照，再进行上面的判断。

## 快照读（Snapshot Read）

MVCC的SELECT操作是快照中的数据，不需要进行加锁操作。

```sql
select * from table;
```

## 当前读（Current Read）

MVCC其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到MVCC并不是完全不用加锁，而只是避免了SELECT的加锁操作。（类似于写入时复制的读写分离思想，读取不加锁，写入时加锁）

当然SELECT操作也可以强制指定进行加锁操作：

```sql
-- 加S锁
SELECT ... LOCK In SHARE MODE;

-- 加X锁
SELECT ... FOR UPDATE;
```

## 临键锁Next-Key Locks

Next-Key Locks是MySQL的InnoDB存储引擎的一种锁实现，目的是解决MVCC无法解决的幻读问题。**在可重复读隔离级别下**，使用MVCC + Next-Key Locks可以解决幻读问题。

### 记录锁Record Locks

**锁定一个记录上的索引，而不是记录本身。**

如果表没有设置索引，InnoDB会自动在主键上创建隐藏的聚簇索引，因此Record Locks依然可以使用。

### 间隙锁Gap Locks

锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c中插入15：

```java
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

### Next-Key Locks

是Record Locks和Gap Locks的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间（即左开右闭区间），例如一个索引包含以下值：10, 11, 13, 20，那么就需要锁定以下区间：

```
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```

## 参考链接

* [数据库系统原理](http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html)