<!--
date: 2022-02-19T22:34:12+08:00
lastmod: 2022-02-20T22:34:12+08:00
-->
## 事务（Transaction）

事务指满足ACID特性的一组操作，通过`Commit`提交一个事务，也可以通过`Rollback`回滚一个事务。

事务的四大特性（ACID）如下：

## 原子性（Atomicity）

事务被视为不可分割的最小单元，事务中的所有操作要么全部执行成功，要么全部执行失败。

回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

## 一致性（Consistency）

数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。

## 隔离性（Isolation）

一个事务所做的修改在最终提交以前，对其它事务是不可见的。在并发情况下，不同事务之间互不干扰。

## 持久性（Durability）

一旦事务提交成功，事务所做的修改都必须持久化到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

## AUTOCOMMIT

MySQL默认采用自动提交模式。也就是说，如果不显式使用`START TRANSACTION;`语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。（在PostgreSQL中使用`BEGIN;`或`BEGIN TRANSACTION;`来开启一个事务；Oracle的事务自动开始于一个DML语句。）

## 并发一致性问题

在并发环境下，事务的隔离性很难保证，因此会出现并发一致性问题。

### 第一类丢失更新

两个事务更新同一个数据，事务A提交，而事务B回滚，则会导致事务A的更新丢失。

这是完全**没有事务隔离级别造成的**。

### 脏读（Dirty Read）

事务A读取到另一个事务B尚未提交的数据，如果事务B回滚了，那么事务A之前读取到的数据就属于脏数据。

### 不可重复读取（Non-Repeatable Read）

事务A在当前事务中多次读取同一个数据，但每次读取结果都不同。比如事务A读取了某一个数据，该数据接下来被另一个事务B所修改，此时事务A再次读取该数据，发现两次读取的数据不一致。

### 第二类丢失更新

和不可重复读本质上是同一类并发问题，通常将它看成不可重复读的特例。

多个事务同时读取同一个数据，并且都对其进行了修改，此时最后一个提交的事务会覆盖其他先提交的事务的改动，导致其他事务的更新丢失，即覆盖更新。

### 幻读（Phanton Read）

本质上也属于不可重复读的情况。

事务A多次读取某个范围的数据（即查询多条记录，不可重复读是查询一条记录），由于事务B在该范围内插入了新数据，导致事务A两次读取的数据不一致。

### 总结

产生并发不一致问题的主要原因是**破坏了事务的隔离性**，解决方法是**通过并发控制来保证隔离性**。

并发控制可以**用封锁来实现**，但封锁操作需要用户自己控制，相当复杂。**数据库管理系统提供了事务的隔离级别**，让用户以一种更轻松的方式处理并发一致性问题。

## 封锁粒度

MySQL中提供了两种封锁粒度：**行级锁以及表级锁**。

应该尽量只锁定需要修改的那部分数据，而不是所有的资源。**锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。**

但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此**封锁粒度越小，系统开销就越大**。

在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。

## 封锁类型

### 读写锁

1）互斥锁（Exclusive），简写为X锁，又称写锁、排他锁。<br>
2）共享锁（Shared），简写为S锁，又称读锁、只读锁。

读写锁的兼容关系如下：

1）一个事务对数据对象A加了X锁，就可以对数据对象A进行读取和更新。加锁期间其它事务不能对数据对象A加任何锁。<br>
2）一个事务对数据对象A加了S锁，就可以对数据对象A进行读取操作，但是不能进行更新操作。加锁期间其它事务能对数据对象A加S锁，但是不能加X锁。

### 意向锁（Intention Locks）

使用意向锁可以更容易地支持多粒度封锁。

由于存在表级锁和行级锁这两种粒度，若事务A想要对某个表加X锁（即表级锁），那么就需要先检测是否存在其他事务对当前表加了表级锁或行级锁，此时需要检测表中的每一行数据，非常耗时。

因此引入了意向锁的概念。意向锁在原本的X/S锁之上引入了意向排他锁IX和意向共享锁IS，**IX和IS都是表级锁**，用来表示一个事务想要在表中的某个数据行上加X锁或S锁。有以下两个规定：

1）一个事务在获得某个**数据行对象**的S锁之前，必须先获得表的IS锁或者更强的锁；<br>
2）一个事务在获得某个**数据行对象**的X锁之前，必须先获得表的IX锁。

在引入意向锁后，若事务想要对整个表加X锁，只需要检测是否有其他事务对当前表加了X/IX/S/IS锁，如果有则加表锁失败。

**任意IS/IX锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁。**

意向锁的目的是避免加表级锁时检测表中每一行数据造成的系统开销，表级的IX锁虽然和表级的X锁不兼容，但和行级的X锁是兼容的。

## 封锁协议

在封锁数据对象时，需要遵守一些规则，即封锁协议。

### 一级封锁协议

事务T要修改数据A时必须加X锁，直到T结束才释放锁。

可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

### 二级封锁协议

在一级的基础上，要求读取数据A时必须加S锁，读取完马上释放S锁。

可以解决读脏数据问题，因为如果一个事务在对数据A进行修改，根据一级封锁协议，会加X锁，那么就不能再加S锁了，也就是不会读入数据。

### 三级封锁协议

在二级的基础上，要求读取数据A时必须加S锁，直到事务结束了才能释放S锁。

可以解决不可重复读的问题，因为读A时，其它事务不能对A加X锁，从而避免了在读的期间数据发生改变。

### 两段锁协议

加锁和解锁分为两个阶段进行。

可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。

事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。

```html
lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
```

但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。

```java
lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
```

### MySQL隐式与显式锁定

MySQL的InnoDB存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。

InnoDB也可以使用特定的语句进行显示锁定：

```sql
-- 加S锁
SELECT ... LOCK In SHARE MODE;

-- 加X锁
SELECT ... FOR UPDATE;
```

## 隔离级别

### 未提交读（READ UNCOMMITTED）

事务中的修改，即使没有提交，对其它事务也是可见的。

### 提交读（READ COMMITTED）

一个事务只能读取已经提交的事务所做的修改。换言之，一个事务所做的修改在提交之前对其它事务是不可见的。

### 可重复读（REPEATABLE READ）

保证在同一个事务中多次读取同一数据的结果是一样的。

### 可串行化（SERIALIZABLE）

强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。

该隔离级别**需要加锁实现**，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。

### 总结

无事务隔离级别：存在第一类丢失更新、脏读、不可重复读、第二类丢失更新和幻读问题。<br>
未提交读级别：存在脏读、不可重复读、第二类丢失更新和幻读问题。<br>
提交读级别：存在不可重复读、第二类丢失更新和幻读问题。<br>
可重复读级别：存在幻读问题。（MySQL的InnoDB存储引擎解决了幻读问题）<br>
可串行化级别： 不存在问题。

事务的隔离级别越高，数据库的并发处理能力就越差。

## 参考链接

* [数据库系统原理](http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html)
* [什么是第一类丢失更新、脏读、不可重复读、第二类丢失更新、幻读 ？](https://www.jianshu.com/p/592b2cdbc589)