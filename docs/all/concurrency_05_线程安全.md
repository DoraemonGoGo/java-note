<!--
date: 2022-02-14T22:46:12+08:00
lastmod: 2022-02-14T22:46:12+08:00
-->
## 线程安全

多个线程并发访问共享资源时，每个线程都能够正常且正确的执行，不会出现数据污染等意外情况，这就是线程安全。

线程安全有如下多种实现方式：

## 不可变对象（Immutable）

若共享资源是不可变对象，则必能保证线程安全。一个不可变对象在被初始化之后，其值就不能被改变，相当于只读不改。有以下不可变的类型：

1）final关键字修饰的基本数据类型<br>
2）String<br>
3）枚举类型<br>
4）基本数据类型对应的包装类型，以及BigInteger和BigDecimal等大数据类型。<br>
5）使用`Collections.unmodifiableCollection()`将集合转变为不可变集合，不可变集合在执行会改变元素的操作时会抛出UnsupportedOperationException。

## 互斥同步

使用synchronized或JUC包的组件等锁机制来对多线程进行互斥同步。

## 非阻塞同步

互斥同步存在一个很重要的问题，即线程的阻塞和唤醒时带来的性能问题（也就是线程的上下文切换），这种同步也称为阻塞同步。

互斥同步使用的是悲观锁策略，无论是否真的存在竞争，在访问共享资源时都会进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。这里仅仅指悲观锁的概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁。

随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，则操作成功，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观锁的许多种实现不需要阻塞线程，因此也称为非阻塞同步。

### CAS

乐观锁的实现，要求操作和冲突检测这个步骤具备原子性，这个需要靠硬件来支持。而硬件支持的原子性操作，最经典的就是CAS，即Compare-and-Swap，比较并交换。

CAS指令需要有3个操作数，分别是内存地址V、旧的预期值A和新值B。当执行操作时，只有当V的值等于A，才将V的值更新为B。

### 原子类

JUC包下提供的原子类（如AtomicInteger），其底层就使用到了Unsafe类的CAS操作。

在多线程下自增、自减运算符并不是线程安全的，此时可以使用原子类的自增等操作来确保线程安全，如AtomicInteger的`incrementAndGet()`。

### ABA问题

CAS在执行时会比较当前值是否是预期的旧值，如果一个变量原本的值是A，先被改为了B，再被改回A，此时CAS操作会认为该变量并没有被改动过，即ABA问题。

JUC包提供了带有标记的原子引用类AtomicStampedReference可以解决这个问题，通过控制变量值的版本来保证 CAS的正确性。不过大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。

## 无同步方案

只有在涉及到共享资源的访问时，才可能存在线程安全问题。换言之，如果没有访问共享资源，就无需进行同步也可保证线程安全。

### 栈封闭

多个线程访问一个方法的局部变量时，不会存在线程安全问题，因为局部变量存储在虚拟机栈中，是线程私有的。

### 线程本地存储（Thread Local Storage）

如果需要访问一个成员变量，该变量又不希望被其他线程访问到，可以使用`java.lang.ThreadLocal`提供的线程本地存储功能，来将该共享资源的可见性限制在当前线程内。这样就不会存在多线程竞争，自然也就不需要进行同步。

每个Thread对象都有一个ThreadLocal.ThreadLocalMap对象，在调用ThreadLocal的`set(T value)`时会将当前的ThreadLocal对象作为key，将value作为值存入该Map中。ThreadLocal的`get()`则是从该Map中获取出来之前存入的值。

在每次使用ThreadLocal后应该尽可能手动调用remove()，以避免出现ThreadLocal经典的内存泄漏、甚至是造成自身业务混乱的风险。

## 参考链接

* [Java 并发](http://www.cyc2018.xyz/Java/Java%20%E5%B9%B6%E5%8F%91.html)