<!--
date: 2022-02-18T22:34:12+08:00
lastmod: 2022-02-19T22:34:12+08:00
-->
## 垃圾收集

垃圾收集（Garbage Collection，通常简称GC），主要是针对堆和方法区进行。

程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。

## 判断一个对象是否可被回收

### 引用计数算法

为对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。引用计数为0的对象可被回收。

但是如果出现了**对象间的循环引用**，此时引用时计数器就永远不会为0，导致无法回收，因此JVM不使用引用计数算法。

### 可达性分析算法

以`GC Roots`为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收（不一定会被回收）。

JVM使用该算法来判断对象是否可被回收，GC Roots一般包含以下内容：

1）虚拟机栈中局部变量表中引用的对象<br>
2）本地方法栈中JNI中引用的对象<br>
3）方法区中类静态属性引用的对象<br>
4）方法区中的常量引用的对象

## 方法区的回收

因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。

主要是对常量池的回收和对类的卸载。

为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。

类的卸载条需要满足以下三个条件，并且满足了条件也不一定会被卸载：

1）该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。<br>
2）加载该类的 ClassLoader 已经被回收。<br>
3）该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

## finalize()

类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。

当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。

* [对象最后一次自我救赎——finalize（）](https://blog.csdn.net/weixin_36586120/article/details/88389365)

## 引用类型

无论使用哪种算法来判断一个对象是否可被回收，都有对象的引用有关。Java提供了以下四种强度不同的引用类型：强、软、弱、虚引用。

### 强引用（Strong Reference）

被强引用关联的对象不会被回收，可以使用`new`一个新对象的方式来创建强引用。

强引用是Java的默认引用实现, 它会尽可能长时间的存活于JVM内。只要强引用还存在，垃圾收集器宁愿抛出OutOfMemory，也不会回收被强引用所引用的对象。

### 软引用（Soft Reference）

被软引用关联的对象只有在内存不够的情况下才会被回收，因此它适合作为缓存使用。

可以使用SoftReference类来创建软引用。

```java
Object obj = new Object();	// 强引用
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

### 弱引用（Weak Reference）

被弱引用关联的对象一定会被回收，换言之，它只能存活到下一次垃圾回收发生之前。弱引用同样可以用于缓存，比如JDK提供的作为缓存使用的[WeakHashMap](/all/container_05_源码分析-Map?id=weakhashmap)容器，底层就使用了弱引用。

可以使用WeakReference类来创建弱引用。

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

### 虚引用（Phantom Reference）

也称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。

为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。

可以使用PhantomReference来创建虚引用，虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用来了解。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null;
```

## 垃圾收集算法

### 标记-清除(Mark-Sweep)

一种分两阶段对对象进行垃圾回收的算法。

在标记阶段，程序会从根结点出发遍历对象，对访问过的对象打上标记，表示该对象可达。

在清除阶段，对有标记的对象取消掉标记位，对没有标记的对象进行回收。回收对象就是把对象作为分块（即被对象占用的内存地址），连接到被称为 “空闲链表” 的单向链表，之后进行分配内存时只需要遍历这个空闲链表，就可以找到分块。回收时会判断回收后的分块与前一个空闲分块是否连续，若连续则会合并这两个分块。

在分配内存时，程序会搜索空闲链表寻找空间大于等于新对象大小size的块block。如果它找到的块等于size，会直接返回这个分块；如果找到的块大于size，会将块分割成大小为size与（block - size）的两部分，返回大小为size的分块，并把大小为（block - size）的块返回给空闲链表。

**不足：**

1）标记和清除过程的效率不高。<br>
2）会产生大量不连续的内存碎片，导致无法给大对象分配内存。

### 复制(Copying)

由于标记-清除算法存在内存碎片化、效率低下的问题，于是提出了复制算法。

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是只使用了内存的一半。

由于新生代大部分对象都不会长时间存活，所以现在的商业虚拟机都**采用这种收集算法回收新生代**。

但是为了提高内存使用率，并不是划分为大小相等的两块，而是分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。在回收时，将Eden和Survivor中还存活着的对象全部复制到另一块Survivor上，最后清理Eden和使用过的那一块Survivor。

HotSpot虚拟机的Eden和Survivor大小比例默认为8:1，保证了内存的利用率达到90%。如果每次回收有多于10%的对象存活，那么一块Survivor就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。

### 标记-整理（Mark-Compact）

为了充分使用内存，又不会生成内存碎片，于是提出了标记-整理算法。

分为标记和整理两个阶段。标记阶段还是一样，而整理阶段则是**让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存**。

优点是不会产生内存碎片，缺点是需要移动大量对象，处理效率较低。因此，该算法适用于老年代的对象。

### 分代收集

鉴于以上三种GC算法的优缺点，因此现在的商业虚拟机采用分代收集算法，根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

一般将堆分为新生代和老年代：

1）新生代使用：复制算法<br>
2）老年代使用：标记-清除 或者 标记-整理算法

## 垃圾收集器

HotSpot虚拟机提供了7个垃圾收集器，除了CMS和G1之外，其它垃圾收集器都是以串行的方式执行。

* [垃圾收集器](http://www.cyc2018.xyz/Java/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.html#垃圾收集器)

## GC类型

在新生代进行的GC叫做Minor GC，在老年代进行的GC都叫Major GC，Full GC同时作用于新生代和老年代。

因为新生代对象存活时间很短，因此Minor GC会频繁执行，执行的速度一般也会比较快。老年代对象其存活时间长，因此Major GC和Full GC很少执行，执行速度会比Minor GC慢很多。

## Stop-The-World

Stop-The-World机制，指的是在执行GC算法时（比如复制算法），为了保证对象的一致性，需要把除了垃圾收集器线程以外的所有线程都挂起，只允许GC线程运行，直到GC结束为止。

不同的垃圾回收器存在着不同程度的Stop-The-World情况，当程序内存不足而又一直难以申请到足够的内存时，就会频繁发生Full GC，从而导致程序卡顿，性能急剧下降。

## 参考链接

* [Java 虚拟机](http://www.cyc2018.xyz/Java/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.html)
* [Java中强、软、弱、虚引用](https://www.cnblogs.com/xdouby/p/6701941.html)
* [Java的引用StrongReference、 SoftReference、 WeakReference 、PhantomReference](https://blog.csdn.net/mxbhxx/article/details/9111711)
* [JVM学习（7）Stop-The-World](https://www.jianshu.com/p/d686e108d15f)