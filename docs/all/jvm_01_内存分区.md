<!--
date: 2022-02-17T22:34:12+08:00
lastmod: 2022-02-19T22:34:12+08:00
-->
## 运行时数据区域

JVM，Java Virtual Machine，即Java虚拟机，是Java能够跨平台执行的关键，它不是真实的物理机，其运行时数据区域（即内存分区）如下图所示：

![jvm1.6](https://cdn.jsdelivr.net/gh/lewky/java-note@main/docs/static/images/jvm1.6.png)

程序计数器、虚拟机栈、本地方法栈这三块内存区域是线程私有的，即每个线程都会开辟私有的内存区域给这三个使用，而堆、方法区则是所有线程共享的内存区域。

## 程序计数器（PC Register）

记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。

JVM的程序计数器并非为广义上所指的物理寄存器，而是对物理PC寄存器的一种抽象模拟，相当于IDE中的光标索引值，行号，表示当前正在编辑的行号。

这是**唯一一个**在Java虚拟机规范中没有任何OutOfMomeryError（OOM）情况的区域。

### 为什么需要使用程序计数器存储字节码指令地址？

因为CPU需要不停地切换线程，当切换回来的时候需要知道当前线程要从哪里继续执行。也正因为存在多线程并发执行的情况（即多个线程同时执行，但CPU在特定时间内只会执行其中一个线程），所以程序计数器是线程私有的。

### 并发、并行、串行的区别？

1）并发是拥有处理多个线程的能力，但同一时刻只能执行其中一个线程，因此CPU会在线程间不停切换。<br>
2）并行是同时执行多个线程，只有多核CPU才能真正做到并行处理。<br>
3）串行是一个接一个执行，执行完一个才能执行下一个。

## Java虚拟机栈

也叫线程栈，方法栈。每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表（Local Variable Array）、操作数栈（Operand Stack）、常量池引用（Reference to Constant Pool）等信息。从方法调用直至执行完成的过程，对应着**一个栈帧在Java虚拟机栈中入栈和出栈**的过程。

该区域可能抛出以下异常：

1）当线程请求的栈深度超过最大值，会抛出StackOverflowError异常（即堆栈溢出）；<br>
2）栈进行动态扩展时如果无法申请到足够内存，会抛出OutOfMemoryError异常（即内存溢出）。

可以通过`-Xss`参数来设置每个线程的虚拟机栈的内存大小：

```java
java -Xss2M
```

## 本地方法栈

与虚拟机栈类似，区别在于本地方法栈是为本地方法服务的。

本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。

## 堆

所有对象都在这里分配内存，是垃圾收集的主要区域。

现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：

1）新生代（Young Generation）<br>
2）老年代（Old Generation）

堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出OutOfMemoryError异常。

可以通过`-Xms`和`-Xmx`这两个JVM参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。

## 方法区

用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出OutOfMemoryError异常。

对这块区域进行垃圾回收的主要目标是**对常量池的回收和对类的卸载**，但是一般比较难实现。

HotSpot虚拟机把它当成永久代来进行垃圾回收，但很难确定永久代的大小。因为它受到很多因素影响，并且每次Full GC之后永久代的大小都会改变，所以经常会抛出OutOfMemoryError异常。为了更容易管理方法区，**从JDK1.8开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。**

**方法区是一个JVM规范，永久代与元空间都是对方法区的一种实现方式。在JDK1.8之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。**

## 运行时常量池

是方法区的一部分，Class文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。

除了在编译期生成的常量，还允许动态生成，例如String类的`intern()`。

## 直接内存（本地内存）

在JDK1.4中新引入了NIO类，它可以使用Native函数库直接分配堆外内存（直接向系统申请的一块内存），然后通过Java堆里的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。

## 参考链接

* [Java 虚拟机](http://www.cyc2018.xyz/Java/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.html)
* [运行时数据区--程序计数器(PC Register)](https://www.cnblogs.com/ding-dang/p/13043290.html)