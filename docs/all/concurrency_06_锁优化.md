<!--
date: 2022-02-13T22:46:12+08:00
lastmod: 2022-02-17T22:46:12+08:00
-->
## 对象头

JDK1.6对synchronized进行了优化，这里涉及到了Java对象头的知识。

存储在内存中的Java对象由对象头、实例数据和对齐填充字节组成，其中的对象头由Mark Word、指向类的指针和数组长度（只有数组对象才有）组成。

Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。在32位JVM中主要存储的是当前对象的HashCode、锁标志位，垃圾回收标记，分代年龄，还会保存指向锁记录（Lock Record）的指针，指向Monitor的指针，偏向锁线程ID等。

Mark Word被设计成一个非固定结构，在运行期间会随着锁标志位的变化而变化。

![Mark Word](https://cdn.jsdelivr.net/gh/lewky/java-note@main/docs/static/images/markword.jpg)

## 实例数据

对象的实例数据就是代码中能看到的对象变量和值。

## 对齐填充字节

因为JVM要求Java的对象占的内存大小应该是8bit的倍数，所以后面有几个字节用于把对象的大小补齐至8bit的倍数，没有特别的功能。

## 锁升级

synchronized实际上是对对象加锁的过程：**锁一段代码需要指定对象，锁一个普通方法时锁的是方法的对象，锁一个静态方法时锁的是方法所在类的对象**。

对对象加锁，就是获取一个对象锁。每一个对象的对象头会关联一个Monitor对象，这个Monitor对象的实现底层是用C++写的，它持有一个计数器，当这个Monitor对象被某个线程获取时，计数器就会加1，被线程释放时就会减1。

在JDK1.6之前，synchronized属于重量级的锁，每次加锁都通过操作系统来申请锁，这里涉及到用户态到内核态的切换，因此效率较低。随着时代发展，多线程并发量越来越大，synchronized的性能显得越发低下。

于是从JDK1.6开始对synchronized进行了优化，在处理同步锁时存在锁升级的概念，级别从低到高依次是：**无锁（unlocked），偏向锁（biasble），轻量级锁（lightweight locked），重量级锁（inflated）**。

锁升级的过程，就是JVM对锁的优化。

## 无锁

不存在竞争，线程不需要获取锁。

Mark Word的后三位存的是是否偏向锁和锁标志位，无锁状态对应的这三位的值是001。

## 偏向锁

当一个线程准备对一个对象加锁时，会验证Mark Word的后三位，当发现是无锁状态时，此时会把对象是否偏向置为1，锁标志位不变（即此时后三位为101），并使用CAS操作把Mark Word的线程ID改为当前线程ID，CAS作成功后对象处于偏向状态。

**偏向锁的思想是让锁偏向于第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连CAS操作也不再需要。**

当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或轻量级锁状态。换言之，偏向锁的升级需要先进行偏向锁的撤销。

## 轻量级锁

轻量级锁同样使用CAS操作来实现：各个线程在自己的线程栈生成锁记录（Lock Record），用CAS操作将Mark Word中指向锁记录的指针指向自己的锁记录。如果CAS操作成功则获得锁，并且对象的Mark Word的锁标记变为00，表示该对象处于轻量级锁状态。而CAS操作没成功的线程则继续循环执行CAS操作直到成功，因此**轻量级锁也叫自旋锁**。

在JDK1.6之前自旋锁的最大自旋次数为10次，JDK1.6对其进行了优化，改为了**自适应的自旋锁**。自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。

## 重量级锁

重量级锁是使用操作系统互斥量（mutex）来实现的传统锁。

自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用CPU时间，因此它只适用于共享数据的锁定状态很短的场景。当竞争线程的自旋次数超过上限时，轻量级锁将会膨胀为重量级锁。

线程不再通过自旋来竞争线程，而是直接进入堵塞状态，此时不消耗CPU，然后等拥有锁的线程释放锁后，唤醒堵塞的线程，然后线程再次竞争锁。

## 锁消除

除了锁升级，JVM还从代码层面对锁进行了优化：锁消除和锁粗化。

当一段代码中加了锁，但JVM通过逃逸分析检测出当前共享数据不可能存在多线程竞争，那么就可以将其当做私有数据来对待，JVM就会将锁消除。

字符串拼接使用StringBuffer的`append()`方法是一个同步方法，每次执行都会加锁，但如果只在一个方法中去拼接局部变量，那么JVM发现其是线程安全的，就可以消除这个锁：

```java
public static String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
```

## 锁粗化

当JVM检测到一系列的连续操作都对同一个对象反复加锁和解锁，那么JVM就可能会将锁的范围扩展到这段代码，只加一个锁，避免频繁的加锁操作导致性能损耗。

比如上述的StringBuffer例子，连续用`append()`拼接了三个字符串，JVM可能会将第一个`append()`的锁范围扩展到最后一个`append()`后面，将原本的三个锁粗化成了一个锁。

## 总结

从偏向锁到轻量级锁是Java内部的优化，属于所谓的用户态，而重量级锁是向操作系统申请，属于内核态。

在锁竞争不激烈的时候由JVM自己解决肯定性能是最好的，但是JVM通过自旋方式解决会消耗CPU性能，所以在锁竞争激烈的情况下重量级锁性能更好。

**锁升级是机制层面的优化，而锁消除和锁粗化则是JVM对代码层面的优化。**

## 参考链接

* [Java 并发](http://www.cyc2018.xyz/Java/Java%20%E5%B9%B6%E5%8F%91.html)
* [简述面试常见问题的锁升级与锁优化](https://baijiahao.baidu.com/s?id=1669027594605610676&wfr=spider&for=pc)
* [锁升级 锁降级](https://zhuanlan.zhihu.com/p/139793053)
* [Java6及以上版本对synchronized的优化](https://www.cnblogs.com/wuqinglong/p/9945618.html)